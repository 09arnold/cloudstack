// Copyright 2012 Citrix Systems, Inc. Licensed under the
// Apache License, Version 2.0 (the "License"); you may not use this
// file except in compliance with the License.  Citrix Systems, Inc.
// reserves all rights not expressly granted by the License.
// You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// Automatically generated by addcopyright.py at 04/03/2012
package com.cloud.test.demo;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Properties;

import com.cloud.test.demo.response.CloudStackPortForwardingRule;
import com.cloud.test.demo.response.CloudStackIpAddress;
import com.cloud.test.demo.response.CloudStackUserVm;
import com.cloud.test.utils.UtilsForTest;
import com.cloud.utils.PropertiesUtil;
import com.google.gson.reflect.TypeToken;
import com.trilead.ssh2.ChannelCondition;
import com.trilead.ssh2.Connection;
import com.trilead.ssh2.Session;

/**
 * @author Alena Prokharchyk
 */
public class Demo {
    private static HashMap<String, Boolean> _apiCommands = new HashMap<String, Boolean>();
    private static Properties properties = new Properties();

    public static void main(String[] args){
        //read properties files
        readCommandsType();
        readDeployConfig();
        String publicIp = createDeployment();
        //setup httpd on the user vms
        //setupHttpd(publicIp, "password");
        
        System.out.println("\nURL is " + "http://" + publicIp + "/cloudcom-faq.html");
    }
    
    private static void readCommandsType() {
        Properties preProcessedCommands = new Properties();
        String configFile = "../conf/demo/commandstype.properties";
        File commandsFile = PropertiesUtil.findConfigFile(configFile);
        try {
            if (commandsFile != null) {
                preProcessedCommands.load(new FileInputStream(commandsFile));
                for (Object key : preProcessedCommands.keySet()) {
                    String strKey = (String)key;
                    String asyncParams = (String)preProcessedCommands.getProperty(strKey);
                    boolean isAsync = false;
                    if (String.valueOf(asyncParams).equalsIgnoreCase("async")) {
                        isAsync=true;
                    }
                    _apiCommands.put(strKey, isAsync);
                }
            } 
        } catch (FileNotFoundException fnfex) {
            System.exit(1);
        } catch (IOException ex) {
            System.out.println("ERROR: Error reading properites file " + configFile);
            System.exit(1);      
        } finally {
            if (commandsFile == null) {
                System.out.println("ERROR: Unable to find properites file " + configFile);
            }
        }
    }
    
    private static void readDeployConfig() {
        String configFile = "../conf/demo/setup.properties";
        File commandsFile = PropertiesUtil.findConfigFile(configFile);
        try {
            if (commandsFile != null) {
                properties.load(new FileInputStream(commandsFile));
            } 
        } catch (FileNotFoundException fnfex) {
            System.exit(1);
        } catch (IOException ex) {
            System.out.println("ERROR: Error reading properites file " + configFile);
            System.exit(1);      
        } finally {
            if (commandsFile == null) {
                System.out.println("ERROR: Unable to find properites file " + configFile);
            }
        }
    }
    
    private static void setupHttpd(String host, String password) {
        if (host == null) {
            System.out.println("Did not receive a host back from test, ignoring ssh test");
            System.exit(1);
        }

        if (password == null) {
            System.out.println("Did not receive a password back from test, ignoring ssh test");
            System.exit(1);
        }

        try {  
            System.out.println("Sleeping for 1 min before trying to ssh into linux host ");
            //Thread.sleep(60000);
            System.out.println("Attempting to SSH into linux host " + host);

            Connection conn = new Connection(host);
            conn.connect(null, 60000, 60000);

            System.out.println("User root ssHed successfully into linux host " + host);

            boolean isAuthenticated = conn.authenticateWithPassword("root", password);

            if (isAuthenticated == false) {
                System.out.println("ERROR: Authentication failed for root with password" + password);
                System.exit(1);
            }

            boolean success = false;
            String linuxCommand = "yum install httpd -y && service httpd start && service iptables stop && cd /var/www/html && wget cloud.com";

            Session sess = conn.openSession();
            System.out.println("User root executing : " + linuxCommand);
            sess.execCommand(linuxCommand);

            InputStream stdout = sess.getStdout();
            InputStream stderr = sess.getStderr();

            byte[] buffer = new byte[8192];
            while (true) {
                if ((stdout.available() == 0) && (stderr.available() == 0)) {
                    int conditions = sess.waitForCondition(ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA | ChannelCondition.EOF, 120000);

                    if ((conditions & ChannelCondition.TIMEOUT) != 0) {
                        System.out.println("ERROR: Timeout while waiting for data from peer.");
                        System.exit(1);
                    }

                    if ((conditions & ChannelCondition.EOF) != 0) {
                        if ((conditions & (ChannelCondition.STDOUT_DATA | ChannelCondition.STDERR_DATA)) == 0) {
                            break;
                        }
                    }
                }

                while (stdout.available() > 0) {
                    success = true;
                    int len = stdout.read(buffer);
                    if (len > 0) 
                        System.out.println(new String(buffer, 0, len));
                }

                while (stderr.available() > 0) {
                    /* int len = */stderr.read(buffer);
                }
            }

            sess.close();
            conn.close();

            if (!success) {
                System.out.println("ERROR: SSH Linux Network test failed: unable to setup httpd");
                System.exit(1);
            }
        } catch (Exception e) {
            System.out.println("ERROR: SSH Linux Network test fail with error " + e.getMessage());
            System.exit(1);
        }
        System.out.println("Httpd is setup succesfully on the user vm");
    }
    
    public static String createDeployment() {
        //1) deployVm
        String urlToSign = "command=deployVirtualMachine&serviceOfferingId=" + properties.getProperty("serviceOfferingId") + 
                "&networkId=" + properties.getProperty("networkId") + 
                "&templateId=" + properties.getProperty("templateId") + "&zoneId=" + properties.getProperty("zoneId");
        String url = UtilsForTest.signUrl(urlToSign, properties.getProperty("apikey"),
                properties.getProperty("secretkey"));
        String requestUrl = "http://" + properties.getProperty("hostname") + ":8080/client/api?" + url;
        System.out.println(requestUrl);
        
        CloudStackHttpClient client = new CloudStackHttpClient();
        
        CloudStackUserVm vm = client.execute(requestUrl, _apiCommands.get("deployVirtualMachine"), "deployvirtualmachineresponse", "virtualmachine", CloudStackUserVm.class);
        
        String vmId = null;
        if(vm != null){
            vmId = vm.getId();
        }
        
        
        //2) List public IP address - source nat
        urlToSign = "command=listPublicIpAddresses&zoneId=" + properties.getProperty("zoneId");
        url = UtilsForTest.signUrl(urlToSign, properties.getProperty("apikey"), 
                properties.getProperty("secretkey"));
        requestUrl = "http://" + properties.getProperty("hostname") + ":8080/client/api?" + url;
        System.out.println(requestUrl);
        
        List<CloudStackIpAddress> ipList = client.execute(requestUrl,"listpublicipaddressesresponse", "publicipaddress", new TypeToken<List<CloudStackIpAddress>>(){}.getType());
        
        
        long ipId=67;
        String ip = "10.223.153.76";
        
        //3) create portForwarding rules for port 22 and 80
        urlToSign = "command=createPortForwardingRule&privateport=22&publicport=22&protocol=tcp&ipaddressid=" + ipId + 
                "&virtualmachineid=" + vmId;
        url = UtilsForTest.signUrl(urlToSign, properties.getProperty("apikey"), 
                properties.getProperty("secretkey"));
        requestUrl = "http://" + properties.getProperty("hostname") + ":8080/client/api?" + url;
        System.out.println(requestUrl);
        CloudStackPortForwardingRule pfrule1 = client.execute(requestUrl, _apiCommands.get("createPortForwardingRule"), "createportforwardingruleresponse", "portforwardingrule", CloudStackPortForwardingRule.class);
        
        urlToSign = "command=createPortForwardingRule&privateport=80&publicport=80&protocol=tcp&ipaddressid=" + ipId + 
                "&virtualmachineid=" + vmId;
        url = UtilsForTest.signUrl(urlToSign, properties.getProperty("apikey"), 
                properties.getProperty("secretkey"));

        requestUrl = "http://" + properties.getProperty("hostname") + ":8080/client/api?" + url;
        System.out.println(requestUrl);
        CloudStackPortForwardingRule pfrule2 = client.execute(requestUrl, _apiCommands.get("createPortForwardingRule"), "createportforwardingruleresponse", "portforwardingrule", CloudStackPortForwardingRule.class);

        
        return ip;
    }
    
}

